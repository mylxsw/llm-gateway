"""
API Key Management Service Module

Provides business logic processing for API Keys.
"""

from datetime import datetime
from typing import Optional

from app.common.errors import ConflictError, NotFoundError, AuthenticationError
from app.common.sanitizer import sanitize_api_key_display
from app.common.utils import generate_api_key
from app.domain.api_key import (
    ApiKeyModel,
    ApiKeyCreate,
    ApiKeyUpdate,
    ApiKeyResponse,
    ApiKeyCreateResponse,
)
from app.repositories.api_key_repo import ApiKeyRepository


class ApiKeyService:
    """
    API Key Management Service
    
    Handles business logic related to API Keys, including creation, authentication, etc.
    """
    
    def __init__(self, repo: ApiKeyRepository):
        """
        Initialize Service
        
        Args:
            repo: API Key Repository
        """
        self.repo = repo
    
    async def create(self, data: ApiKeyCreate) -> ApiKeyCreateResponse:
        """
        Create API Key
        
        key_value is automatically generated by the system.
        
        Args:
            data: Creation data
        
        Returns:
            ApiKeyCreateResponse: Created API Key (key_value fully displayed)
        
        Raises:
            ConflictError: Name already exists
        """
        # Check if name already exists
        existing = await self.repo.get_by_name(data.key_name)
        if existing:
            raise ConflictError(
                message=f"API Key with name '{data.key_name}' already exists",
                code="duplicate_name",
            )
        
        # Generate random key_value
        key_value = generate_api_key()
        
        api_key = await self.repo.create(data, key_value)
        
        # Return full key_value on creation
        return ApiKeyCreateResponse(
            id=api_key.id,
            key_name=api_key.key_name,
            key_value=api_key.key_value,  # Full display
            is_active=api_key.is_active,
            created_at=api_key.created_at,
            last_used_at=api_key.last_used_at,
        )
    
    async def get_by_id(self, id: int) -> ApiKeyResponse:
        """
        Get API Key by ID
        
        Args:
            id: API Key ID
        
        Returns:
            ApiKeyResponse: API Key info (key_value sanitized)
        
        Raises:
            NotFoundError: API Key not found
        """
        api_key = await self.repo.get_by_id(id)
        if not api_key:
            raise NotFoundError(
                message=f"API Key with id {id} not found",
                code="api_key_not_found",
            )
        return self._to_response(api_key)
    
    async def get_all(
        self,
        is_active: Optional[bool] = None,
        page: int = 1,
        page_size: int = 20,
    ) -> tuple[list[ApiKeyResponse], int]:
        """
        Get API Key List
        
        Args:
            is_active: Filter by active status
            page: Page number
            page_size: Items per page
        
        Returns:
            tuple[list[ApiKeyResponse], int]: (API Key list, Total count)
        """
        api_keys, total = await self.repo.get_all(is_active, page, page_size)
        return [self._to_response(k) for k in api_keys], total
    
    async def update(self, id: int, data: ApiKeyUpdate) -> ApiKeyResponse:
        """
        Update API Key
        
        Args:
            id: API Key ID
            data: Update data
        
        Returns:
            ApiKeyResponse: Updated API Key
        
        Raises:
            NotFoundError: API Key not found
            ConflictError: Name already used by another Key
        """
        existing = await self.repo.get_by_id(id)
        if not existing:
            raise NotFoundError(
                message=f"API Key with id {id} not found",
                code="api_key_not_found",
            )
        
        # If updating name, check for conflict with other Keys
        if data.key_name and data.key_name != existing.key_name:
            name_conflict = await self.repo.get_by_name(data.key_name)
            if name_conflict:
                raise ConflictError(
                    message=f"API Key with name '{data.key_name}' already exists",
                    code="duplicate_name",
                )
        
        api_key = await self.repo.update(id, data)
        return self._to_response(api_key)  # type: ignore
    
    async def delete(self, id: int) -> None:
        """
        Delete API Key
        
        Args:
            id: API Key ID
        
        Raises:
            NotFoundError: API Key not found
        """
        existing = await self.repo.get_by_id(id)
        if not existing:
            raise NotFoundError(
                message=f"API Key with id {id} not found",
                code="api_key_not_found",
            )
        
        await self.repo.delete(id)
    
    async def authenticate(self, key_value: str) -> ApiKeyModel:
        """
        Authenticate API Key
        
        Args:
            key_value: API Key value
        
        Returns:
            ApiKeyModel: Authenticated API Key
        
        Raises:
            AuthenticationError: Authentication failed
        """
        if not key_value:
            raise AuthenticationError(
                message="API Key is required",
                code="invalid_api_key",
            )
        
        # Remove Bearer prefix
        if key_value.lower().startswith("bearer "):
            key_value = key_value[7:]
        
        api_key = await self.repo.get_by_key_value(key_value)
        
        if not api_key:
            raise AuthenticationError(
                message="Invalid API Key",
                code="invalid_api_key",
            )
        
        if not api_key.is_active:
            raise AuthenticationError(
                message="API Key is disabled",
                code="api_key_disabled",
            )
        
        # Update last used time
        await self.repo.update_last_used(api_key.id, datetime.utcnow())
        
        return api_key
    
    def _to_response(self, api_key: ApiKeyModel) -> ApiKeyResponse:
        """
        Convert ApiKeyModel to response model (key_value sanitized)
        
        Args:
            api_key: API Key model
        
        Returns:
            ApiKeyResponse: Response model
        """
        return ApiKeyResponse(
            id=api_key.id,
            key_name=api_key.key_name,
            key_value=sanitize_api_key_display(api_key.key_value),
            is_active=api_key.is_active,
            created_at=api_key.created_at,
            last_used_at=api_key.last_used_at,
        )
